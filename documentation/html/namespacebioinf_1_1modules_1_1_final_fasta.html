<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>MBI: bioinf.modules.FinalFasta Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MBI
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>bioinf</b></li><li class="navelem"><b>modules</b></li><li class="navelem"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html">FinalFasta</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bioinf.modules.FinalFasta Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa789ecfde12b33a6ea9247cf26cc51c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa789ecfde12b33a6ea9247cf26cc51c4"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#aa789ecfde12b33a6ea9247cf26cc51c4">readBlosum</a> (fname)</td></tr>
<tr class="memdesc:aa789ecfde12b33a6ea9247cf26cc51c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from file the Blosum table. <br /></td></tr>
<tr class="separator:aa789ecfde12b33a6ea9247cf26cc51c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4327bb857a732165e5edeb1989e7008c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#a4327bb857a732165e5edeb1989e7008c">getTuplesList</a> (str, k)</td></tr>
<tr class="memdesc:a4327bb857a732165e5edeb1989e7008c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find k-length tuples of characters (nucleotides) in the DNA sequence provided.  <a href="#a4327bb857a732165e5edeb1989e7008c">More...</a><br /></td></tr>
<tr class="separator:a4327bb857a732165e5edeb1989e7008c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86525ac43d87de05023a26eb55b224d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86525ac43d87de05023a26eb55b224d4"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#a86525ac43d87de05023a26eb55b224d4">createDiagonalDict</a> (seq, seqRef, k)</td></tr>
<tr class="memdesc:a86525ac43d87de05023a26eb55b224d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dict with diagonal num as key and an array with one empty DiagonalRun object as value. <br /></td></tr>
<tr class="separator:a86525ac43d87de05023a26eb55b224d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0497a9f35f1e0952f4282dd110c76a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f0497a9f35f1e0952f4282dd110c76a"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#a7f0497a9f35f1e0952f4282dd110c76a">createDiagonalDictFrom</a> (bestDiagonals)</td></tr>
<tr class="memdesc:a7f0497a9f35f1e0952f4282dd110c76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty dictionary with keys copied from the dictionary taken from function parameter. <br /></td></tr>
<tr class="separator:a7f0497a9f35f1e0952f4282dd110c76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210370c139f58238e900eeed5bbc5787"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#a210370c139f58238e900eeed5bbc5787">calcDiagonalSums</a> (seq, seqRef, tuplesRef, tuplesRefDict, k)</td></tr>
<tr class="memdesc:a210370c139f58238e900eeed5bbc5787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dictionary where each diagonal get assigned an array containg one diagonal run object storing all hotspots found on that diagonal.  <a href="#a210370c139f58238e900eeed5bbc5787">More...</a><br /></td></tr>
<tr class="separator:a210370c139f58238e900eeed5bbc5787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701b478dee8297fe192968b2ec117fae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#a701b478dee8297fe192968b2ec117fae">createMatrixForDots</a> (diagonalDict, seq, seqRef, k)</td></tr>
<tr class="memdesc:a701b478dee8297fe192968b2ec117fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug function creating a scoreMatrix for seq and seqRef.  <a href="#a701b478dee8297fe192968b2ec117fae">More...</a><br /></td></tr>
<tr class="separator:a701b478dee8297fe192968b2ec117fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56b4c39dcb4b6cb38a32f909feec2bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab56b4c39dcb4b6cb38a32f909feec2bc"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#ab56b4c39dcb4b6cb38a32f909feec2bc">printDotMatrix</a> (seq, seqRef, matrix)</td></tr>
<tr class="memdesc:ab56b4c39dcb4b6cb38a32f909feec2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug function for printing Dot matrix(Shouldn't be used, slows down the calculation) <br /></td></tr>
<tr class="separator:ab56b4c39dcb4b6cb38a32f909feec2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293c50c66432fb49e0c1f31fc93662f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a293c50c66432fb49e0c1f31fc93662f6"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#a293c50c66432fb49e0c1f31fc93662f6">listAllRegions</a> (diagonalRegionsDict)</td></tr>
<tr class="memdesc:a293c50c66432fb49e0c1f31fc93662f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all diagonal runs from the given diagonal dictionary. <br /></td></tr>
<tr class="separator:a293c50c66432fb49e0c1f31fc93662f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7424825e31c7dccceaf6668efb3511"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec7424825e31c7dccceaf6668efb3511"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#aec7424825e31c7dccceaf6668efb3511">getDictWithTopRegions</a> (diagonals)</td></tr>
<tr class="memdesc:aec7424825e31c7dccceaf6668efb3511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the given diagonal dictionary and returns a dictionary with ten diagonal runs with best value. <br /></td></tr>
<tr class="separator:aec7424825e31c7dccceaf6668efb3511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0580cdbe9b834843aaa8a4dbf3c5e9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#a3f0580cdbe9b834843aaa8a4dbf3c5e9">scoreDiagonalRuns</a> (diagonalDict, seq, seqRef, k, gapPenalty, reward)</td></tr>
<tr class="memdesc:a3f0580cdbe9b834843aaa8a4dbf3c5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">In order to evaluate each diagonal run, FASTA gives each hot spot a positive score, and the space between consecutive hot spots in a run is given a negative score (gapPenalty) the score of the diagonal run is the sum of the hot spots scores and the interspot scores (only if the score with gaps is higher than without).  <a href="#a3f0580cdbe9b834843aaa8a4dbf3c5e9">More...</a><br /></td></tr>
<tr class="separator:a3f0580cdbe9b834843aaa8a4dbf3c5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33172668788cbd06479858af6340ae6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#ae33172668788cbd06479858af6340ae6">rescoreDiagonals</a> (seq, seqRef, blosum, bestDiagonalsDict, k, cutoff)</td></tr>
<tr class="memdesc:ae33172668788cbd06479858af6340ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescore diagonal runs.  <a href="#ae33172668788cbd06479858af6340ae6">More...</a><br /></td></tr>
<tr class="separator:ae33172668788cbd06479858af6340ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fc1dcdd8c66b6080747d7f145a75a8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#a50fc1dcdd8c66b6080747d7f145a75a8">createAlignmentString</a> (alignedSeq, alignedSeqRef)</td></tr>
<tr class="memdesc:a50fc1dcdd8c66b6080747d7f145a75a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a special string showing identities, gaps, and mismatches.  <a href="#a50fc1dcdd8c66b6080747d7f145a75a8">More...</a><br /></td></tr>
<tr class="separator:a50fc1dcdd8c66b6080747d7f145a75a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7646a8318372530d94ddfd4ac6c2084b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#a7646a8318372530d94ddfd4ac6c2084b">fastaScoreAlignment</a></td></tr>
<tr class="memdesc:a7646a8318372530d94ddfd4ac6c2084b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method calculating and scoring and alignment of two sequences using FastA algorithm.  <a href="#a7646a8318372530d94ddfd4ac6c2084b">More...</a><br /></td></tr>
<tr class="separator:a7646a8318372530d94ddfd4ac6c2084b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09864371c84b7d9849902fdf4e075735"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09864371c84b7d9849902fdf4e075735"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#a09864371c84b7d9849902fdf4e075735">readDb</a> (fname)</td></tr>
<tr class="memdesc:a09864371c84b7d9849902fdf4e075735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read reference sequences from a file to an array. <br /></td></tr>
<tr class="separator:a09864371c84b7d9849902fdf4e075735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cc9cfb13b7d32f06f009fefb4f361e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebioinf_1_1modules_1_1_final_fasta.html#a10cc9cfb13b7d32f06f009fefb4f361e">fasta</a></td></tr>
<tr class="memdesc:a10cc9cfb13b7d32f06f009fefb4f361e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method searching a database of reference DNA sequences.  <a href="#a10cc9cfb13b7d32f06f009fefb4f361e">More...</a><br /></td></tr>
<tr class="separator:a10cc9cfb13b7d32f06f009fefb4f361e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@!package FinalFasta
Find the best match between query sequence and reference sequences from a database
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a210370c139f58238e900eeed5bbc5787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def bioinf.modules.FinalFasta.calcDiagonalSums </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seqRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tuplesRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tuplesRefDict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a dictionary where each diagonal get assigned an array containg one diagonal run object storing all hotspots found on that diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>Query sequence which will be compared against a reference sequence </td></tr>
    <tr><td class="paramname">seqRef</td><td>Reference sequence </td></tr>
    <tr><td class="paramname">tuplesRef</td><td>A set containing all k-length tuples found in the reference sequence </td></tr>
    <tr><td class="paramname">tuplesRefDict</td><td>Dictionary with tuples found in the reference sequence as keys and empty arrays for items </td></tr>
    <tr><td class="paramname">k</td><td>Length of tuples of nucleotides that the algorithm is looking for in any two sequences compared with each other. Should be between 2 and 6 for DNA sequences</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Dictionary</td><td>with diagonals containing at least 1 hotspot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50fc1dcdd8c66b6080747d7f145a75a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def bioinf.modules.FinalFasta.createAlignmentString </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alignedSeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alignedSeqRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a special string showing identities, gaps, and mismatches. </p>
<p>This string is printed between the two aligned sequences and shows the identities (|), gaps (-), and mismatches (:). As the string is constructed, it also counts number of identities, gaps, and mismatches and returns the counts along with the alignment string.</p>
<p>AAGGATGCCTCAAATCGATCT-TTTTCTTGG- ::||::::::||:|::::::: |: :||:| &lt;&ndash; alignment string CTGGTACTTGCAGAGAAGGGGGTA&ndash;ATTTGG </p>

</div>
</div>
<a class="anchor" id="a701b478dee8297fe192968b2ec117fae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def bioinf.modules.FinalFasta.createMatrixForDots </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>diagonalDict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seqRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debug function creating a scoreMatrix for seq and seqRef. </p>
<p>Drawing dot matrix is unnecessary since it takes too much memory to remember all values </p>

</div>
</div>
<a class="anchor" id="a10cc9cfb13b7d32f06f009fefb4f361e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def bioinf.modules.FinalFasta.fasta </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gapPenalty</em> = <code>-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rescoreCutoff</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matchReward</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>db</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>blosum</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method searching a database of reference DNA sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>Query sequence which will be compared against reference sequences </td></tr>
    <tr><td class="paramname">k</td><td>Length of tuples of nucleotides that the algorithm is looking for in any two sequences compared with each other. Should be between 2 and 6 for DNA sequences </td></tr>
    <tr><td class="paramname">gapPenalty</td><td>Penalty for opening a gap. The penalty is linear. Must be negative. </td></tr>
    <tr><td class="paramname">restoreCutoff</td><td>A threshold for filtering out diagonal runs with too low of a score (during rescore stage using BLOSUM matrix). Must be negative </td></tr>
    <tr><td class="paramname">matchReward</td><td>Value used when scoring diagonal runs and two nucleotides. Must be positive </td></tr>
    <tr><td class="paramname">db</td><td>An array containing reference sequences. In case nothing is entered for this parameter, a default database is read from a text file </td></tr>
    <tr><td class="paramname">blosum</td><td>Name of the text file containing substitution matrix. In case nothing is entered, a default text file is read </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">An</td><td>array of arrays containing results for comparison with each sequence from reference databas. Each sequence generates the following results: init1 - best diagonal run after scoring previously found diagonal runs with substitution matrix (the diagonal run may contain mismatches) init_n - best result achieved after chaining best diagonal runs (the result may contain indels and mismatches) opt - result of Smith-Waterman algorithm for the init1 diagonal run i - index of the referenece sequence in the database refStartIndex - index of the first character in the reference sequence belonging to the alignment length - length of the alignment found in the reference sequence mismatched - number of mismatches in the alignment that was found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7646a8318372530d94ddfd4ac6c2084b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def bioinf.modules.FinalFasta.fastaScoreAlignment </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seqRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gapPenalty</em> = <code>-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rescoreCutoff</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matchReward</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>blosum</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method calculating and scoring and alignment of two sequences using FastA algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>Query sequence which will be compared against a reference sequence </td></tr>
    <tr><td class="paramname">seqRef</td><td>Reference sequence </td></tr>
    <tr><td class="paramname">k</td><td>Length of tuples of nucleotides that the algorithm is looking for in any two sequences compared with each other. Should be between 2 and 6 for DNA sequences </td></tr>
    <tr><td class="paramname">gapPenalty</td><td>Penalty for opening a gap. The penalty is linear. Must be negative. </td></tr>
    <tr><td class="paramname">restoreCutoff</td><td>A threshold for filtering out diagonal runs with too low of a score (during rescore stage using BLOSUM matrix). Must be negative </td></tr>
    <tr><td class="paramname">matchReward</td><td>Value used when scoring diagonal runs and two nucleotides. Must be positve </td></tr>
    <tr><td class="paramname">blosum</td><td>Dictionary with the substitution matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">An</td><td>array containing results for comparison with the given reference sequence. The results containg: init1 - best diagonal run after scoring previously found diagonal runs with substitution matrix (the diagonal run may contain mismatches) init_n - best result achieved after chaining best diagonal runs (the result may contain indels and mismatches) opt - result of Smith-Waterman algorithm for the init1 diagonal run seqAligned - Aligned query sequence seqRefAligned - Aligned reference sequence refStartIndex - index of the first character in the reference sequence belonging to the alignment length - length of the alignment found in the reference sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4327bb857a732165e5edeb1989e7008c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def bioinf.modules.FinalFasta.getTuplesList </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find k-length tuples of characters (nucleotides) in the DNA sequence provided. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">a</td><td>tuple containg (set of tuples, dictionary with tuples as key and empty array for item) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae33172668788cbd06479858af6340ae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def bioinf.modules.FinalFasta.rescoreDiagonals </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seqRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>blosum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bestDiagonalsDict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rescore diagonal runs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>Query sequence which will be compared against a reference sequence </td></tr>
    <tr><td class="paramname">seqRef</td><td>Reference sequence </td></tr>
    <tr><td class="paramname">blosum</td><td>Dictionary with the substitution matrix. It uses tuples of two characters as string, e.g.: 'A', 'C' </td></tr>
    <tr><td class="paramname">bestDiagonalsDict</td><td>Dictionary where each diagonal (the key is the number of a diagonal, can be negative) has an array of diagonal runs </td></tr>
    <tr><td class="paramname">k</td><td>Length of tuples of nucleotides that the algorithm is looking for in any two sequences compared with each other. Should be between 2 and 6 for DNA sequences </td></tr>
    <tr><td class="paramname">cutoff</td><td>A threshold for filtering out diagonal runs with too low of a score (during rescore stage using BLOSUM matrix). Must be negative</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">(Dictionary</td><td>with diagonal numbers as keys and DiagonalRun objects as items, init1 (best DiagonaRun)) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f0580cdbe9b834843aaa8a4dbf3c5e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def bioinf.modules.FinalFasta.scoreDiagonalRuns </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>diagonalDict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seqRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gapPenalty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In order to evaluate each diagonal run, FASTA gives each hot spot a positive score, and the space between consecutive hot spots in a run is given a negative score (gapPenalty) the score of the diagonal run is the sum of the hot spots scores and the interspot scores (only if the score with gaps is higher than without). </p>
<p>FASTA finds the 10 highest scoring diagonal runs under this evaluating scheme. Each diagonal may contain more than 1 diagonal run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagonalDict</td><td>Dictionary where each diagonal (the key is the number of a diagonal, can be negative) has an array of diagonal runs associated with it </td></tr>
    <tr><td class="paramname">seq</td><td>Query sequence which will be compared against a reference sequence </td></tr>
    <tr><td class="paramname">seqRef</td><td>Reference sequence </td></tr>
    <tr><td class="paramname">k</td><td>Length of tuples of nucleotides that the algorithm is looking for in any two sequences compared with each other. Should be between 2 and 6 for DNA sequences </td></tr>
    <tr><td class="paramname">gapPenalty</td><td>Penalty for opening a gap. The penalty is linear. Must be negative. </td></tr>
    <tr><td class="paramname">reward</td><td>Value used when scoring diagonal runs and two nucleotides. Must be positive</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">(Dictionary</td><td>with diagonal numbers as keys and DiagonalRun objects as items, init1 (best DiagonaRun)) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 15 2015 20:48:00 for MBI by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
